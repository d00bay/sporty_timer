// SPDX-License-Identifier: GPL-3.0-or-later
/**
 * @file ssd1306.c
 * @brief ATtiny85 Workout Timer
 * @author Matt Dube https://github.com/d00bay
 *
 * Hardware: ATtiny85 (8MHz Internal), SSD1306 OLED (I2C)
 *
 * Style Guidelines:
 *  - Identation: 2 spaces
 *  - Naming: snake_case
 *  - Structure: One statement per line
 */
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include "i2c_master.h"
#include "ssd1306.h"

#define OLED_ADDR 0x3C

// --- FONT (Space through 'Z') ---
// Covers ASCII 32 (' ') to 90 ('Z')
const uint8_t font[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, // Space (32)
    0x00, 0x00, 0x5F, 0x00, 0x00, // !
    0x00, 0x07, 0x00, 0x07, 0x00, // "
    0x14, 0x7F, 0x14, 0x7F, 0x14, // #
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
    0x23, 0x13, 0x08, 0x64, 0x62, // %
    0x36, 0x49, 0x55, 0x22, 0x50, // &
    0x00, 0x05, 0x03, 0x00, 0x00, // '
    0x00, 0x1C, 0x22, 0x41, 0x00, // (
    0x00, 0x41, 0x22, 0x1C, 0x00, // )
    0x14, 0x08, 0x3E, 0x08, 0x14, // *
    0x08, 0x08, 0x3E, 0x08, 0x08, // +
    0x00, 0x50, 0x30, 0x00, 0x00, // ,
    0x08, 0x08, 0x08, 0x08, 0x08, // -
    0x00, 0x60, 0x60, 0x00, 0x00, // .
    0x20, 0x10, 0x08, 0x04, 0x02, // /
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
    0x00, 0x42, 0x7F, 0x40, 0x00, // 1
    0x42, 0x61, 0x51, 0x49, 0x46, // 2
    0x21, 0x41, 0x45, 0x4B, 0x31, // 3
    0x18, 0x14, 0x12, 0x7F, 0x10, // 4
    0x27, 0x45, 0x45, 0x45, 0x39, // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
    0x01, 0x71, 0x09, 0x05, 0x03, // 7
    0x36, 0x49, 0x49, 0x49, 0x36, // 8
    0x06, 0x49, 0x49, 0x29, 0x1E, // 9
    0x00, 0x36, 0x36, 0x00, 0x00, // :
    0x00, 0x56, 0x36, 0x00, 0x00, // ;
    0x08, 0x14, 0x22, 0x41, 0x00, // <
    0x14, 0x14, 0x14, 0x14, 0x14, // =
    0x00, 0x41, 0x22, 0x14, 0x08, // >
    0x02, 0x01, 0x51, 0x09, 0x06, // ?
    0x32, 0x49, 0x79, 0x41, 0x3E, // @
    0x7E, 0x11, 0x11, 0x11, 0x7E, // A
    0x7F, 0x49, 0x49, 0x49, 0x36, // B
    0x3E, 0x41, 0x41, 0x41, 0x22, // C
    0x7F, 0x41, 0x41, 0x22, 0x1C, // D
    0x7F, 0x49, 0x49, 0x49, 0x41, // E
    0x7F, 0x09, 0x09, 0x09, 0x01, // F
    0x3E, 0x41, 0x49, 0x49, 0x7A, // G
    0x7F, 0x08, 0x08, 0x08, 0x7F, // H
    0x00, 0x41, 0x7F, 0x41, 0x00, // I
    0x20, 0x40, 0x41, 0x3F, 0x01, // J
    0x7F, 0x08, 0x14, 0x22, 0x41, // K
    0x7F, 0x40, 0x40, 0x40, 0x40, // L
    0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
    0x7F, 0x04, 0x08, 0x10, 0x7F, // N
    0x3E, 0x41, 0x41, 0x41, 0x3E, // O
    0x7F, 0x09, 0x09, 0x09, 0x06, // P
    0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
    0x7F, 0x09, 0x19, 0x29, 0x46, // R
    0x46, 0x49, 0x49, 0x49, 0x31, // S
    0x01, 0x01, 0x7F, 0x01, 0x01, // T
    0x3F, 0x40, 0x40, 0x40, 0x3F, // U
    0x1F, 0x20, 0x40, 0x20, 0x1F, // V
    0x3F, 0x40, 0x38, 0x40, 0x3F, // W
    0x63, 0x14, 0x08, 0x14, 0x63, // X
    0x07, 0x08, 0x70, 0x08, 0x07, // Y
    0x61, 0x51, 0x49, 0x45, 0x43  // Z
};


static void oled_cmd(uint8_t cmd) {
  i2c_start();
  i2c_write(OLED_ADDR << 1);
  i2c_write(0x00);
  i2c_write(cmd);
  i2c_stop();
}

// --- SCALED DRAWING (4x) ---
static void draw_big_digit(uint8_t index, uint8_t col, uint8_t row) {
  // Offset index 16 to match 0-9 in the new font array
  // '0' is ASCII 48. The font array starts at 32 (Space).
  // So '0' is at index 16.
  uint8_t font_index = index + 16; 
  if (index == 10) font_index = 26; // Special case for colon

  for (uint8_t p = 0; p < 4; p++) {
    oled_cmd(0x20); 
    oled_cmd(0x02);
    oled_cmd(0xB0 + row + p);
    oled_cmd(0x00 + (col & 0x0F)); 
    oled_cmd(0x10 + ((col >> 4) & 0x0F)); 
    
    i2c_start();
    i2c_write(OLED_ADDR << 1);
    i2c_write(0x40);
    
    for (uint8_t i = 0; i < 5; i++) {
      uint8_t src = pgm_read_byte(&font[font_index * 5 + i]);
      uint8_t twoBits = (src >> (p * 2)) & 0x03;
      uint8_t pattern = 0x00;
      if (twoBits & 0x01) 
        pattern |= 0x0F; 
      if (twoBits & 0x02) 
        pattern |= 0xF0; 
      
      for(uint8_t k=0; k<4; k++) 
        i2c_write(pattern);
    }
    i2c_write(0x00); 
    i2c_write(0x00);
    i2c_stop();
  }
}

// --- PUBLIC FUNCTIONS ---

void ssd1306_init(void) {
  I2C_PORT |= (1<<I2C_SDA) | (1<<I2C_SCL);
  oled_cmd(0xAE); 
  oled_cmd(0xD5); 
  oled_cmd(0x80);
  oled_cmd(0xA8); 
  oled_cmd(0x3F);
  oled_cmd(0x8D); 
  oled_cmd(0x14); 
  oled_cmd(0x20); 
  oled_cmd(0x00); 
  oled_cmd(0xA1); 
  oled_cmd(0xC8); 
  oled_cmd(0xDA); 
  oled_cmd(0x12);
  oled_cmd(0x81); 
  oled_cmd(0xCF);
  oled_cmd(0xAF); 
  ssd1306_clear();
}

void ssd1306_clear(void) {
  oled_cmd(0x20); 
  oled_cmd(0x00);
  oled_cmd(0x21); 
  oled_cmd(0); 
  oled_cmd(127);
  oled_cmd(0x22); 
  oled_cmd(0); 
  oled_cmd(7);
  i2c_start();
  i2c_write(OLED_ADDR << 1);
  i2c_write(0x40);
  for(uint16_t i=0; i<1024; i++) 
    i2c_write(0x00);
  i2c_stop();
}

void ssd1306_draw_time(uint8_t minutes, uint8_t seconds) {
  draw_big_digit(minutes / 10, 0, 2);
  draw_big_digit(minutes % 10, 26, 2);
  draw_big_digit(10, 52, 2); // Colon
  draw_big_digit(seconds / 10, 78, 2);
  draw_big_digit(seconds % 10, 104, 2);
}

// NEW: Print standard text
void ssd1306_print(uint8_t x, uint8_t page, const char *str) {
  oled_cmd(0x20); 
  oled_cmd(0x02); // Page Addressing Mode
  oled_cmd(0xB0 + page);          // Set Page Start
    
// Set Lower and Higher Column Address based on x
  oled_cmd(0x00 + (x & 0x0F));
  oled_cmd(0x10 + ((x >> 4) & 0x0F));

  i2c_start();
  i2c_write(OLED_ADDR << 1);
  i2c_write(0x40); // Data stream

  while (*str) {
    uint8_t c = *str;
  // Font starts at ' ' (32). Ensure we don't read before array
    uint8_t font_index = (c < 32) ? 0 : (c - 32);
    // Cap at 'Z' to prevent reading garbage if we passed lowercase
    if (font_index > 58) 
      font_index = 0; // fallback

    for (uint8_t i = 0; i < 5; i++) {
      i2c_write(pgm_read_byte(&font[font_index * 5 + i]));
    }
    i2c_write(0x00); // 1px space between chars
    str++;
  }
  i2c_stop();
}

// NEW: Flash screen (Invert colors)
void ssd1306_flash_screen(uint8_t count) {
  for (uint8_t i = 0; i < count; i++) {
    oled_cmd(0xA7); // Inverse Display (White background, Black text)
    _delay_ms(100);
    oled_cmd(0xA6); // Normal Display
    _delay_ms(100);
  }
}
